[
    {
        "DesignPattern": "Ambassador pattern",
        "Description": "Create helper services that send network requests on behalf of a consumer service or application. An ambassador service can be thought of as an out-of-process proxy that is co-located with the client.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/ambassador"
    },
    {
        "DesignPattern": "Anti-corruption Layer pattern",
        "Description": "Implement a fa√ßade or adapter layer between different subsystems that don't share the same semantics. This layer translates requests that one subsystem makes to the other subsystem. Use this pattern to ensure that an application's design is not limited by dependencies on outside subsystems. This pattern was first described by Eric Evans in Domain-Driven Design.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer"
    },
    {
        "DesignPattern": "Asynchronous Request-Reply pattern",
        "Description": "Decouple backend processing from a frontend host, where backend processing needs to be asynchronous, but the frontend still needs a clear response.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/async-request-reply"
    },
    {
        "DesignPattern": "Backends for Frontends pattern",
        "Description": "Create separate backend services to be consumed by specific frontend applications or interfaces. This pattern is useful when you want to avoid customizing a single backend for multiple interfaces. This pattern was first described by Sam Newman.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/backends-for-frontends"
    },
    {
        "DesignPattern": "Bulkhead pattern",
        "Description": "The Bulkhead pattern is a type of application design that is tolerant of failure. In a bulkhead architecture, elements of an application are isolated into pools so that if one fails, the others will continue to function. It's named after the sectioned partitions (bulkheads) of a ship's hull. If the hull of a ship is compromised, only the damaged section fills with water, which prevents the ship from sinking.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/bulkhead"
    },
    {
        "DesignPattern": "Cache-Aside pattern",
        "Description": "Load data on demand into a cache from a data store. This can improve performance and also helps to maintain consistency between data held in the cache and data in the underlying data store.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/cache-aside"
    },
    {
        "DesignPattern": "Choreography pattern",
        "Description": "Have each component of the system participate in the decision-making process about the workflow of a business transaction, instead of relying on a central point of control.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/choreography"
    },
    {
        "DesignPattern": "Circuit Breaker pattern",
        "Description": "Handle faults that might take a variable amount of time to recover from, when connecting to a remote service or resource. This can improve the stability and resiliency of an application.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker"
    },
    {
        "DesignPattern": "Claim-Check pattern",
        "Description": "Split a large message into a claim check and a payload. Send the claim check to the messaging platform and store the payload to an external service. This pattern allows large messages to be processed, while protecting the message bus and the client from being overwhelmed or slowed down. This pattern also helps to reduce costs, as storage is usually cheaper than resource units used by the messaging platform.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/claim-check"
    },
    {
        "DesignPattern": "Compensating Transaction pattern",
        "Description": "When you use an eventually consistent operation that consists of a series of steps, the Compensating Transaction pattern can be useful. Specifically, if one or more of the steps fail, you can use the Compensating Transaction pattern to undo the work that the steps performed. Typically, you find operations that follow the eventual consistency model in cloud-hosted applications that implement complex business processes and workflows.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction"
    },
    {
        "DesignPattern": "Competing Consumers pattern",
        "Description": "Enable multiple concurrent consumers to process messages received on the same messaging channel. With multiple concurrent consumers, a system can process multiple messages concurrently to optimize throughput, to improve scalability and availability, and to balance the workload.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers"
    },
    {
        "DesignPattern": "Compute Resource Consolidation pattern",
        "Description": "Consolidate multiple tasks or operations into a single computational unit. This can increase compute resource utilization, and reduce the costs and management overhead associated with performing compute processing in cloud-hosted applications.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/compute-resource-consolidation"
    },
    {
        "DesignPattern": "CQRS pattern",
        "Description": "CQRS stands for Command and Query Responsibility Segregation, a pattern that separates read and update operations for a data store. Implementing CQRS in your application can maximize its performance, scalability, and security. The flexibility created by migrating to CQRS allows a system to better evolve over time and prevents update commands from causing merge conflicts at the domain level.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs"
    },
    {
        "DesignPattern": "Deployment Stamps pattern",
        "Description": "The deployment stamp pattern involves provisioning, managing, and monitoring a heterogeneous group of resources to host and operate multiple workloads or tenants. Each individual copy is called a stamp, or sometimes a service unit, scale unit, or cell. In a multitenant environment, every stamp or scale unit can serve a predefined number of tenants. Multiple stamps can be deployed to scale the solution almost linearly and serve an increasing number of tenants. This approach can improve the scalability of your solution, allow you to deploy instances across multiple regions, and separate your customer data.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/deployment-stamp"
    },
    {
        "DesignPattern": "",
        "Description": "The great variety of systems and devices on the shop floor can make workload configuration a difficult problem. This article provides approaches to solving it.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/edge-workload-configuration"
    },
    {
        "DesignPattern": "Event Sourcing pattern",
        "Description": "Instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data. The store acts as the system of record and can be used to materialize the domain objects. This can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness. It can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing"
    },
    {
        "DesignPattern": "External Configuration Store pattern",
        "Description": "Move configuration information out of the application deployment package to a centralized location. This can provide opportunities for easier management and control of configuration data, and for sharing configuration data across applications and application instances.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/external-configuration-store"
    },
    {
        "DesignPattern": "Federated Identity pattern",
        "Description": "Delegate authentication to an external identity provider. This can simplify development, minimize the requirement for user administration, and improve the user experience of the application.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/federated-identity"
    },
    {
        "DesignPattern": "Gatekeeper pattern",
        "Description": "Protect applications and services by using a dedicated host instance to broker requests between clients and the application or service. The broker validates and sanitizes the requests, and can provide an additional layer of security and limit the system's attack surface.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/gatekeeper"
    },
    {
        "DesignPattern": "Gateway Aggregation pattern",
        "Description": "Use a gateway to aggregate multiple individual requests into a single request. This pattern is useful when a client must make multiple calls to different backend systems to perform an operation.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/gateway-aggregation"
    },
    {
        "DesignPattern": "Gateway Offloading pattern",
        "Description": "Offload shared or specialized service functionality to a gateway proxy. This pattern can simplify application development by moving shared service functionality, such as the use of SSL certificates, from other parts of the application into the gateway.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/gateway-offloading"
    },
    {
        "DesignPattern": "Gateway Routing pattern",
        "Description": "Route requests to multiple services or multiple service instances using a single endpoint. The pattern is useful when you want to:",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/gateway-routing"
    },
    {
        "DesignPattern": "Geode pattern",
        "Description": "The Geode pattern involves deploying a collection of backend services into a set of geographical nodes, each of which can service any request for any client in any region. This pattern allows serving requests in an active-active style, improving latency and increasing availability by distributing request processing around the globe.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/geodes"
    },
    {
        "DesignPattern": "Health Endpoint Monitoring pattern",
        "Description": "To verify that applications and services are performing correctly, you can use the Health Endpoint Monitoring pattern. This pattern specifies the use of functional checks in an application. External tools can access these checks at regular intervals through exposed endpoints.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/health-endpoint-monitoring"
    },
    {
        "DesignPattern": "Index Table pattern",
        "Description": "Create indexes over the fields in data stores that are frequently referenced by queries. This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/index-table"
    },
    {
        "DesignPattern": "Leader Election pattern",
        "Description": "Coordinate the actions performed by a collection of collaborating instances in a distributed application by electing one instance as the leader that assumes responsibility for managing the others. This can help to ensure that instances don't conflict with each other, cause contention for shared resources, or inadvertently interfere with the work that other instances are performing.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/leader-election"
    },
    {
        "DesignPattern": "Materialized View pattern",
        "Description": "Generate prepopulated views over the data in one or more data stores when the data isn't ideally formatted for required query operations. This can help support efficient querying and data extraction, and improve application performance.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/materialized-view"
    },
    {
        "DesignPattern": "Pipes and Filters pattern",
        "Description": "Decompose a task that performs complex processing into a series of separate elements that can be reused. Doing so can improve performance, scalability, and reusability by allowing task elements that perform the processing to be deployed and scaled independently.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/pipes-and-filters"
    },
    {
        "DesignPattern": "Priority Queue pattern",
        "Description": "Prioritize requests sent to services so that requests with a higher priority are received and processed more quickly than those with a lower priority. This pattern is useful in applications that offer different service level guarantees to individual clients.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/priority-queue"
    },
    {
        "DesignPattern": "Publisher-Subscriber pattern",
        "Description": "Enable an application to announce events to multiple interested consumers asynchronously, without coupling the senders to the receivers.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber"
    },
    {
        "DesignPattern": "Queue-Based Load Leveling pattern",
        "Description": "Use a queue that acts as a buffer between a task and a service it invokes in order to smooth intermittent heavy loads that can cause the service to fail or the task to time out. This can help to minimize the impact of peaks in demand on availability and responsiveness for both the task and the service.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling"
    },
    {
        "DesignPattern": "Rate Limiting pattern",
        "Description": "Many services use a throttling pattern to control the resources they consume, imposing limits on the rate at which other applications or services can access them. You can use a rate limiting pattern to help you avoid or minimize throttling errors related to these throttling limits and to help you more accurately predict throughput.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/rate-limiting-pattern"
    },
    {
        "DesignPattern": "Retry pattern",
        "Description": "Enable an application to handle transient failures when it tries to connect to a service or network resource, by transparently retrying a failed operation. This can improve the stability of the application.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
    },
    {
        "DesignPattern": "Saga distributed transactions pattern",
        "Description": "The Saga design pattern is a way to manage data consistency across microservices in distributed transaction scenarios. A saga is a sequence of transactions that updates each service and publishes a message or event to trigger the next transaction step. If a step fails, the saga executes compensating transactions that counteract the preceding transactions.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga"
    },
    {
        "DesignPattern": "Scheduler Agent Supervisor pattern",
        "Description": "Coordinate a set of distributed actions as a single operation. If any of the actions fail, try to handle the failures transparently, or else undo the work that was performed, so the entire operation succeeds or fails as a whole. This can add resiliency to a distributed system, by enabling it to recover and retry actions that fail due to transient exceptions, long-lasting faults, and process failures.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/scheduler-agent-supervisor"
    },
    {
        "DesignPattern": "Sequential Convoy pattern",
        "Description": "Process a set of related messages in a defined order, without blocking processing of other groups of messages.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/sequential-convoy"
    },
    {
        "DesignPattern": "Sharding pattern",
        "Description": "Divide a data store into a set of horizontal partitions or shards. This can improve scalability when storing and accessing large volumes of data.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/sharding"
    },
    {
        "DesignPattern": "Sidecar pattern",
        "Description": "Deploy components of an application into a separate process or container to provide isolation and encapsulation. This pattern can also enable applications to be composed of heterogeneous components and technologies.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/sidecar"
    },
    {
        "DesignPattern": "Static Content Hosting pattern",
        "Description": "Deploy static content to a cloud-based storage service that can deliver them directly to the client. This can reduce the need for potentially expensive compute instances.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/static-content-hosting"
    },
    {
        "DesignPattern": "Strangler Fig pattern",
        "Description": "Incrementally migrate a legacy system by gradually replacing specific pieces of functionality with new applications and services. As features from the legacy system are replaced, the new system eventually replaces all of the old system's features, strangling the old system and allowing you to decommission it.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/strangler-fig"
    },
    {
        "DesignPattern": "Throttling pattern",
        "Description": "Control the consumption of resources used by an instance of an application, an individual tenant, or an entire service. This can allow the system to continue to function and meet service level agreements, even when an increase in demand places an extreme load on resources.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling"
    },
    {
        "DesignPattern": "Valet Key pattern",
        "Description": "Use a token that provides clients with restricted direct access to a specific resource, in order to offload data transfer from the application. This is particularly useful in applications that use cloud-hosted storage systems or queues, and can minimize cost and maximize scalability and performance.",
        "Link": "https://learn.microsoft.com/en-us/azure/architecture/patterns/valet-key"
    }
]